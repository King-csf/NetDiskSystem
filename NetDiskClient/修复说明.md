# 文件传输进度条重置问题修复说明

## 问题描述
在进行多文件传输时，当上一个文件传输完成后，开始传输新文件时，上一次传输的文件的进度条会重新从0开始前进，完成时才会继续传输后面的文件。

## 问题原因
原代码中所有文件传输都共用同一个 `FileTrans` 对象 (`filetrans`)，当开始新文件传输时：
1. `filetrans->reInit(filePath)` 会重新初始化对象
2. 这导致之前文件的传输信息被覆盖
3. 进度条显示逻辑混乱，出现重置现象

## 修复方案

### 1. 为每个文件创建独立的FileTrans对象
- 修改 `mainwindow.cpp` 中的 `on_pushButton_clicked()` 方法
- 每次上传文件时创建新的 `FileTrans` 对象，而不是重用全局对象
- 确保每个文件的传输状态独立管理

### 2. 添加对象生命周期管理
- 在 `mainwindow.h` 中添加 `QList<FileTrans*> activeTransfers` 来跟踪活跃的传输对象
- 在传输完成后自动清理对象，防止内存泄漏
- 在析构函数中确保所有对象都被正确清理

### 3. 修复的关键代码变更

#### mainwindow.h
```cpp
// 添加活跃传输对象管理
QList<FileTrans*> activeTransfers;
```

#### mainwindow.cpp
```cpp
// 为每个文件创建独立的FileTrans对象
FileTrans* currentFileTrans = new FileTrans(4);
currentFileTrans->curFilePath = filetrans->curFilePath;
currentFileTrans->reInit(filePath);

// 添加到活跃传输列表
activeTransfers.append(currentFileTrans);

// 传输完成后清理对象
if(uploadList[url] == 4) {
    // 传输完成，清理FileTrans对象
    activeTransfers.removeOne(currentFileTrans);
    currentFileTrans->deleteLater();
}
```

## 修复效果
1. **进度条独立显示**：每个文件的进度条不再相互干扰
2. **内存管理优化**：传输完成的对象会被自动清理
3. **并发传输支持**：支持多个文件同时传输而不会出现状态混乱
4. **稳定性提升**：避免了对象重用导致的各种异常情况

## 测试验证
1. 选择多个文件进行连续上传
2. 观察每个文件的进度条是否独立显示
3. 确认上一个文件完成后，其进度条保持100%状态
4. 验证新文件的进度条从0%正常开始
5. 检查内存使用情况，确保没有内存泄漏

## 注意事项
- 此修复保持了原有的4线程传输机制
- 不影响断点续传等其他功能
- 兼容现有的UI显示逻辑
- 提升了代码的可维护性和稳定性